--- module-cyclocopter.cc	2016-09-06 00:22:57.747444624 +0530
+++ module-cyclocopter_kuldeep.cc	2016-09-06 00:38:03.015404264 +0530
@@ -39,16 +39,16 @@
 
 #include "mbconfig.h"           /* This goes first in every *.c,*.cc file */
 
-// #include <limits>
+#include <limits>
 #include <cmath>
-// #include <map>
+#include <map>
 
 #include "dataman.h"
 #include "userelem.h"
 #include "indvel.h"
 
 // For CyclocopterDMST
-// #include <vector>
+#include <vector>
 #include "aeroelem.h"
 #include <complex>
 
@@ -862,14 +862,6 @@
 CyclocopterUniform1D::GetInducedVelocity(Elem::Type type,
 	unsigned uLabel, unsigned uPnt, const Vec3& X) const
 {
-	Vec3 temp;
-	temp(1) = 1 ; 
-	temp(2) = 1 ; 
-	temp(3) = 1 ; 
-	// std::cout << std::abs(temp) << std::endl;
-	std::cout << "okay"  << std::endl;
-	std::cout << RRot3 << std::endl;
-
 	return RRot3*dUindMean;
 }
 
@@ -1221,20 +1213,13 @@
 CyclocopterUniform2D::GetInducedVelocity(Elem::Type type,
 	unsigned uLabel, unsigned uPnt, const Vec3& X) const
 {
-	//printf("%f %f %f\n",dUind(1),dUind(2),dUind(3));
-	std::cout << RRotor << std::endl;
-	
 	return RRotor*dUind;
-
 }
-
 /* CyclocopterUniform2D - end */
 
 
 /* CyclocopterPolimi - begin */
-
 /*
-
 The induced velocity is opposite to
 the force generated by the rotor in the plane
 perdendicular to the rotor rotation axis. The
@@ -1245,7 +1230,6 @@
 Vi(r) = Kc*cos((pi/2)*(r/R)) + Ks*sin(pi*(r/R))
 where the cofficients Kc and Ks are based on the
 momentum theory
-
 */
 
 class CyclocopterPolimi
@@ -1587,7 +1571,7 @@
 
 /*AUTHOR: Kuldeep Singh <kuldeepsingh050895@gmail.com>
 Copyright (C) 2016(-2016) all rights reserved.
-The copyright of this patch is transferred
+The copyright of this patch(For the class CyclocopterDMST or DMST Module) is transferred
 to Pierangelo Masarati and Paolo Mantegazza
 for use in the software MBDyn as described 
 in the GNU Public License version 2.1 */
@@ -1620,7 +1604,7 @@
 	std::vector<Vec3> dUindBlade;
 	mutable std::vector<Vec3> dUindPrevBlade;
 
-	std::vector<Vec3> dBladeFroce; // Blade force in global reference frame
+	std::vector<Vec3> dBladeForce; // Blade force in global reference frame
 
 	// This stores the induce velocity magnitude at each azimuth location
 	// this will be updated after every iteration to keep the it updated
@@ -1766,7 +1750,6 @@
 
 	DriveCaller *pdW = 0;
 	doublereal dOmegaFilter;
-	// doublereal dDeltaT;
 	
 	if (!ReadUniform(pDM, HP, uLabel, bFlagAverage, dRadius, dSpan, pdW, dOmegaFilter, dKappa, dDeltaT, dOmega)) {
 		throw ErrGeneric(MBDYN_EXCEPT_ARGS);
@@ -1775,14 +1758,26 @@
 	ppRes = ReadResSets(pDM, HP);
 
 	//reading labels from input file ans later use something like push_pack function so that fix number 6 do not come into the picture  
-	uBlade.resize(6);
-	/*this 6 should be replaced by Number of blades*/
-	NBlades = uBlade.size();
-	for (int i = 0; i < NBlades; ++i)
+	// After reading the labels fix the no of blades 
+
+	// uBlade.resize(6);
+	// NBlades = uBlade.size();
+	// for (int i = 0; i < NBlades; ++i)
+	// {
+	// 	uBlade[i] = HP.GetInt(); 
+	// }
+
+	int BladeLabel = 1 ;
+	while(BladeLabel)
 	{
-		// After reading the labels fix the no of blades 
-		uBlade[i] = HP.GetInt(); 
+		// std::cout << "BladeLabel \t" << uBlade.size() << "\t" << BladeLabel << std::endl;
+		BladeLabel = HP.GetInt();
+		if (BladeLabel != 0)
+		{
+			uBlade.push_back(BladeLabel);
+		}
 	}
+	NBlades = uBlade.size();
 
 	SetOutputFlag(pDM->fReadOutput(HP, Elem::INDUCEDVELOCITY));
 
@@ -1814,7 +1809,7 @@
 	}
 
 	//Defining the size to store the corresponding values
-	dBladeFroce.resize(NBlades); 
+	dBladeForce.resize(NBlades); 
 	dBladePos.resize(NBlades); 
 	dAngleBtBladeAndNetforce.resize(NBlades); 
 	dBladeUind.resize(NBlades);
@@ -1916,395 +1911,396 @@
 	/* Transpose of the rotor rotation matrix */
 	RRotor = pCraft->GetRCurr()*RRot;
 	RRotorTranspose = RRotor.Transpose();
+
 	/* Force in the rotor coordinate system */
 	F = RRotorTranspose*Res.Force();
-	if (!bFlagAverage || bFlagAverage) // For both the case it should do the same  
+	/* filter the forces */
+	Uk = F;
+	Yk = -Yk_1*a1 - Yk_2*a2 + Uk*b0 + Uk_1*b1 + Uk_2*b2;
+	F = Yk;
+
+	///////////////////////////////////////////////////////////////
+	// 2D Model
+	/* Force in the plane normal to the rotation axis */
+	doublereal dT = sqrt(F(2)*F(2) + F(3)*F(3));
+	/* Induced velocity: calculated according to dT */
+	doublereal dRho = dGetAirDensity(GetXCurr());
+	dUindMean = dKappa*sqrt(dT/(2*dRho*dArea));
+	/* Induced velocity components in the coordinate
+ 	* system of the rotor */
+	dUind = ::Zero3;
+	if (dT > std::numeric_limits<doublereal>::epsilon()) 
 	{
-		/* filter the forces */
-		Uk = F;
-		Yk = -Yk_1*a1 - Yk_2*a2 + Uk*b0 + Uk_1*b1 + Uk_2*b2;
-		F = Yk;
+		dUind(2) = dUindMean*F(2)/dT;
+		dUind(3) = dUindMean*F(3)/dT;
+	}
+	dUind(1) = (1 - dWeight)*dUind(1) + dWeight*dUindPrev(1);
+	dUind(2) = (1 - dWeight)*dUind(2) + dWeight*dUindPrev(2);
+	dUind(3) = (1 - dWeight)*dUind(3) + dWeight*dUindPrev(3);
 
-		///////////////////////////////////////////////////////////////
-		// 2D Model
-		/* Force in the plane normal to the rotation axis */
-		doublereal dT = sqrt(F(2)*F(2) + F(3)*F(3));
-		/* Induced velocity: calculated according to dT */
-		doublereal dRho = dGetAirDensity(GetXCurr());
-		dUindMean = dKappa*sqrt(dT/(2*dRho*dArea));
-		/* Induced velocity components in the coordinate
-	 	* system of the rotor */
-		dUind = ::Zero3;
-		if (dT > std::numeric_limits<doublereal>::epsilon()) 
-		{
-			dUind(2) = dUindMean*F(2)/dT;
-			dUind(3) = dUindMean*F(3)/dT;
-		}
-		dUind(1) = (1 - dWeight)*dUind(1) + dWeight*dUindPrev(1);
-		dUind(2) = (1 - dWeight)*dUind(2) + dWeight*dUindPrev(2);
-		dUind(3) = (1 - dWeight)*dUind(3) + dWeight*dUindPrev(3);
+	dUindMean = sqrt(dUind(1)*dUind(1) + dUind(2)*dUind(2) + dUind(3)*dUind(3));
 
-		dUindMean = sqrt(dUind(1)*dUind(1) + dUind(2)*dUind(2) + dUind(3)*dUind(3));
 
+	//////////////////////////////////////////////////////////////////////
+	// DMST Model
+	Vec3 NetFroce = RRotorTranspose*Res.Force(); //(0, Fx, Fy) Net rotor force
 
-		//////////////////////////////////////////////////////////////////////
-		// DMST Model
-		doublereal dKappaDMST = 1.15 ; // 3D effect 
-		Vec3 NetFroce = RRotorTranspose*Res.Force(); //(0, Fx, Fy) Net rotor force
+	for (int i = 0; i < NBlades; ++i)
+	{
+		dBladeForce[i] = RRotorTranspose*pBladeAero[i]->dGetForces(); // storing the all blade force 
+		dBladePos[i] = RRotorTranspose*pBladeAero[i]->dGetPosition(); // storind the position of blades
+		dAngleBtBladeAndNetforce[i] = acos(dBladePos[i].Dot(NetFroce)/sqrt(dBladePos[i].Dot(dBladePos[i] * NetFroce.Dot(NetFroce))));
 		
-		if (NetFroce.Norm() == 0) 
 		// At first time step NetForce is (0,0,0) but it should be nonzero vector because angle with respect to null vector is undefined 
+		if (NetFroce.Norm() == 0)
 		{
-			//So randomly defining NetForce as a nonzero vector  
-			// it will be used only at first step
-			NetFroce(1) = 0.;
-			NetFroce(2) = 1.;
-			NetFroce(3) = 0.;
-		}
+			dAngleBtBladeAndNetforce[i] = 2*i*M_PI/NBlades;
+		} 
+	}
 
-		for (int i = 0; i < NBlades; ++i)
-		{
-			dBladeFroce[i] = RRotorTranspose*pBladeAero[i]->dGetForces(); // storing the all blade force 
-			dBladePos[i] = RRotorTranspose*pBladeAero[i]->dGetPosition(); // storind the position of blades
-			dAngleBtBladeAndNetforce[i] = acos(dBladePos[i].Dot(NetFroce)/sqrt(dBladePos[i].Dot(dBladePos[i] * NetFroce.Dot(NetFroce))));
-		}
+	// Updating the dIndVelMegAll  
+	for (int i = 0; i < NBlades; ++i)
+	{
+		 doublereal psi = atan2(dBladePos[i](3),dBladePos[i](2)); // Azimuth location of the blade i 
+		 if (psi < 0)
+		 {
+		 	psi = psi + 2*M_PI; // atan2() range (-PI, PI) so to make it (0, 2*PI) => -psi = psi + 2*PI 
+		 }
+		 int index = floor(psi/(dOmega*dDeltaT)); // where to change the induced velocity
+		 dIndVelMegAll[index] = sqrt((dKappa*dBladeForce[i].Norm()*NBlades*pow(sin((M_PI/2)-dAngleBtBladeAndNetforce[i]),2))/(4*M_PI*dRho*dRadius));
+	}
+	////////////////////////////////
+	// Upper half and Lower half both 
+	// Because until we have nonzero U_up, we can not get nonzero "w"  
+	// and without nonzero "w" the root method will not give U_d 
+	////////////////////////////////	
+	#if 1
+	if(EmptyCheck == true)
+	{
+		std::cout << "One" << std::endl;
 
-		// Updating the dIndVelMegAll  
+		// Calculating magnitude of Induced velocity of individual blade
 		for (int i = 0; i < NBlades; ++i)
-		{
-			 doublereal psi = atan2(dBladePos[i](3),dBladePos[i](2)); // Azimuth location of the blade i 
-			 if (psi < 0)
-			 {
-			 	psi = psi + 2*M_PI; // atan2() range (-PI, PI) so to make it (0, 2*PI) => -psi = psi + 2*PI 
-			 }
-			 int index = floor(psi/(dOmega*dDeltaT)); // where to change the induced velocity
-			 dIndVelMegAll[index] = sqrt((dKappaDMST*dBladeFroce[i].Norm()*NBlades*pow(sin((M_PI/2)-dAngleBtBladeAndNetforce[i]),2))/(4*M_PI*dRho*dRadius));
+		{	
+			// Induced velocity magnitude is calculated using the blade force of the individual blade and the Azimuth location of the blade
+			dBladeUindMag[i] = sqrt((dKappa*dBladeForce[i].Norm()*NBlades*pow(sin((M_PI/2)-dAngleBtBladeAndNetforce[i]),2))/(4*M_PI*dRho*dRadius));
+
+			// Calculating the Induced velocity component for Upper half
+			dBladeUind[i] = ::Zero3;
+			if (dT > std::numeric_limits<doublereal>::epsilon())
+			{
+				// Option 1: Blade Azimuth location
+				// dBladeUind[i](2) = dBladeUindMag[i]*dBladePos[i](2)/dBladePos[i].Norm();
+				// dBladeUind[i](3) = dBladeUindMag[i]*dBladePos[i](3)/dBladePos[i].Norm();
+
+				// Option 2: Local blade net force vector direction
+				// dBladeUind[i](2) = dBladeUindMag[i]*dBladeForce[i](2)/dBladeForce[i].Norm();
+				// dBladeUind[i](3) = dBladeUindMag[i]*dBladeForce[i](3)/dBladeForce[i].Norm();
+				
+				// Option 3: Rotor, Net thrust vector direction
+				dBladeUind[i](2) = dBladeUindMag[i]*F(2)/dT;
+				dBladeUind[i](3) = dBladeUindMag[i]*F(3)/dT;
+
+				// Option 4: Given in the Article BRNDICT ET AL   
+				// dBladeUind[i](3) = -dBladeUindMag[i];
+			
+			}
+			dBladeUind[i](1) = (1 - dWeight)*dBladeUind[i](1) + dWeight*dBladeUindPrev[i](1);
+			dBladeUind[i](2) = (1 - dWeight)*dBladeUind[i](2) + dWeight*dBladeUindPrev[i](2);
+			dBladeUind[i](3) = (1 - dWeight)*dBladeUind[i](3) + dWeight*dBladeUindPrev[i](3);
+			// std::cout << dBladeUindMag[i] << std::endl;
 		}
-		////////////////////////////////
-		// Upper half and Lower half both 
-		// Because until we have nonzero U_up, we can not get nonzero "w"  
-		// and without nonzero "w" the root method will not give U_d 
-		////////////////////////////////	
-		#if 1
-		if(EmptyCheck == true)
-		{
-			std::cout << "One" << std::endl;
+	}
+	#endif
 
-			// Calculating magnitude of Induced velocity of individual blade
-			for (int i = 0; i < NBlades; ++i)
-			{	
+	if (EmptyCheck == false)
+	{
+		std::cout << "Both" << std::endl;
+		// Calculating magnitude of Induced velocity of individual blade
+		for (int i = 0; i < NBlades; ++i)
+		{	
+			////////////////////////////////
+			// Upper half
+			////////////////////////////////	
+			if (cos(dAngleBtBladeAndNetforce[i]) > 0) // Angle between NetForce and Blade position is in range (-PI/2, PI/2) 
+			{
 				// Induced velocity magnitude is calculated using the blade force of the individual blade and the Azimuth location of the blade
-				dBladeUindMag[i] = sqrt((dKappaDMST*dBladeFroce[i].Norm()*NBlades*pow(sin((M_PI/2)-dAngleBtBladeAndNetforce[i]),2))/(4*M_PI*dRho*dRadius));
+				dBladeUindMag[i] = sqrt((dKappa*dBladeForce[i].Norm()*NBlades*pow(sin((M_PI/2)-dAngleBtBladeAndNetforce[i]),2))/(4*M_PI*dRho*dRadius));
 
 				// Calculating the Induced velocity component for Upper half
 				dBladeUind[i] = ::Zero3;
 				if (dT > std::numeric_limits<doublereal>::epsilon())
 				{
 					// Option 1: Blade Azimuth location
-					dBladeUind[i](2) = dBladeUindMag[i]*dBladePos[i](2)/dBladePos[i].Norm();
-					dBladeUind[i](3) = dBladeUindMag[i]*dBladePos[i](3)/dBladePos[i].Norm();
+					// dBladeUind[i](2) = dBladeUindMag[i]*dBladePos[i](2)/dBladePos[i].Norm();
+					// dBladeUind[i](3) = dBladeUindMag[i]*dBladePos[i](3)/dBladePos[i].Norm();
 
 					// Option 2: Local blade net force vector direction
-					// dBladeUind[i](2) = dBladeUindMag[i]*dBladeFroce[i](2)/dBladeFroce[i].Norm();
-					// dBladeUind[i](3) = dBladeUindMag[i]*dBladeFroce[i](3)/dBladeFroce[i].Norm();
+					// dBladeUind[i](2) = -dBladeUindMag[i]*dBladeForce[i](2)/dBladeForce[i].Norm();
+					// dBladeUind[i](3) = -dBladeUindMag[i]*dBladeForce[i](3)/dBladeForce[i].Norm();
 					
 					// Option 3: Rotor, Net thrust vector direction
-					// dBladeUind[i](2) = dBladeUindMag[i]*F(2)/dT;
-					// dBladeUind[i](3) = dBladeUindMag[i]*F(3)/dT;
+					dBladeUind[i](2) = dBladeUindMag[i]*F(2)/dT;
+					dBladeUind[i](3) = dBladeUindMag[i]*F(3)/dT;
 
 					// Option 4: Given in the Article BRNDICT ET AL   
-					// dBladeUind[i](3) = -dBladeUindMag[i];
- 			
+					// dBladeUind[i](3) = -dBladeUindMag[i];	
 				}
+
 				dBladeUind[i](1) = (1 - dWeight)*dBladeUind[i](1) + dWeight*dBladeUindPrev[i](1);
 				dBladeUind[i](2) = (1 - dWeight)*dBladeUind[i](2) + dWeight*dBladeUindPrev[i](2);
 				dBladeUind[i](3) = (1 - dWeight)*dBladeUind[i](3) + dWeight*dBladeUindPrev[i](3);
+
 				// std::cout << dBladeUindMag[i] << std::endl;
+
 			}
-		}
-		#endif
+			/////////////////////////////////
+			// Lower half
+			/////////////////////////////////
+			else // (dAngleBtBladeAndNetforce[i]) < 0)
+			{
+				doublereal w;
+				int MirrorPointIndex; // Lower half blade position's mirror image point in the upper half 
+				// VECTOR ABOUT WHICH MIRROR IMAGE IS TAKEN, IS VECTOR ORTHOGNAL TO THE NetForce Vector which is = (0, -NetFroce(3), NetFroce(2)) 
+
+				Vec3 NetFroceOrtho = ::Zero3; // Vector Orthogonal to Net force Vector 
+				NetFroceOrtho(2) = NetFroce(3);  
+				NetFroceOrtho(3) = -NetFroce(2);  
+				
+				doublereal m = atan2(NetFroceOrtho(3), NetFroceOrtho(2)); // Slop of the line
 
-		if (EmptyCheck == false)
-		{
-			std::cout << "Both" << std::endl;
-			// Calculating magnitude of Induced velocity of individual blade
-			for (int i = 0; i < NBlades; ++i)
-			{	
-				////////////////////////////////
-				// Upper half
-				////////////////////////////////	
-				if (cos(dAngleBtBladeAndNetforce[i]) > 0) // Angle between NetForce and Blade position is in range (-PI/2, PI/2) 
-				{
-					// Induced velocity magnitude is calculated using the blade force of the individual blade and the Azimuth location of the blade
-					dBladeUindMag[i] = sqrt((dKappaDMST*dBladeFroce[i].Norm()*NBlades*pow(sin((M_PI/2)-dAngleBtBladeAndNetforce[i]),2))/(4*M_PI*dRho*dRadius));
+				doublereal a = dBladePos[i](2) ; 
+				doublereal b = dBladePos[i](3) ;
+				
+				doublereal c = ((2*(m*b+a))/(m*m+1)) - a ; // Mirror image point first coordinate  
+				doublereal d = ((2*m*(m*b+a))/(m*m+1)) - b ; // Mirror image point second coordinate 
 
-					// Calculating the Induced velocity component for Upper half
-					dBladeUind[i] = ::Zero3;
-					if (dT > std::numeric_limits<doublereal>::epsilon())
-					{
-						// Option 1: Blade Azimuth location
-						dBladeUind[i](2) = dBladeUindMag[i]*dBladePos[i](2)/dBladePos[i].Norm();
-						dBladeUind[i](3) = dBladeUindMag[i]*dBladePos[i](3)/dBladePos[i].Norm();
-
-						// Option 2: Local blade net force vector direction
-						// dBladeUind[i](2) = -dBladeUindMag[i]*dBladeFroce[i](2)/dBladeFroce[i].Norm();
-						// dBladeUind[i](3) = -dBladeUindMag[i]*dBladeFroce[i](3)/dBladeFroce[i].Norm();
-						
-						// Option 3: Given in the Article BRNDICT ET AL   
-						// dBladeUind[i](3) = -dBladeUindMag[i];	
-					}
 
-					dBladeUind[i](1) = (1 - dWeight)*dBladeUind[i](1) + dWeight*dBladeUindPrev[i](1);
-					dBladeUind[i](2) = (1 - dWeight)*dBladeUind[i](2) + dWeight*dBladeUindPrev[i](2);
-					dBladeUind[i](3) = (1 - dWeight)*dBladeUind[i](3) + dWeight*dBladeUindPrev[i](3);
+				doublereal MirrorAzimuth = atan2(d,c); // Mirror image point's Azimuth angle in the global frame 
+				if (MirrorAzimuth < 0)
+				{
+					MirrorAzimuth = MirrorAzimuth + 2*M_PI ; 
+				}
+				MirrorPointIndex = MirrorAzimuth / (dOmega*dDeltaT);
+				
 
-					// std::cout << dBladeUindMag[i] << std::endl;
+				w = 2*dIndVelMegAll[MirrorPointIndex]/sin(dAngleBtBladeAndNetforce[i] - M_PI/2);
 
-				}
-				/////////////////////////////////
-				// Lower half
-				/////////////////////////////////
-				else // (dAngleBtBladeAndNetforce[i]) < 0)
-				{
-					doublereal w;
-					int MirrorPointIndex; // Lower half blade position's mirror image point in the upper half 
-					// VECTOR ABOUT WHICH MIRROR IMAGE IS TAKEN, IS VECTOR ORTHOGNAL TO THE NetForce Vector which is = (0, -NetFroce(3), NetFroce(2)) 
-
-					Vec3 NetFroceOrtho = ::Zero3; // Vector Orthogonal to Net force Vector 
-					NetFroceOrtho(2) = NetFroce(3);  
-					NetFroceOrtho(3) = -NetFroce(2);  
-					
-					doublereal m = atan2(NetFroceOrtho(3), NetFroceOrtho(2)); // Slop of the line
+				//////////////////////////////////////////
+				//Find induced velocity using roots   
+				#if 1
+				// Direct root calculation method to find the induced velocity in lower-half of the rotor
+				float sinPhi = sin(dAngleBtBladeAndNetforce[i] - M_PI/2);
+				float Gamma = pow(((dKappa*dBladeForce[i].Norm()*NBlades)/(4*M_PI*dRho*dRadius)),2);
+				/*x1, x2, x3 and x4 are the roots of the 4th order polynomial*/
+				std::complex<double> x1 = 0+0j; 	
+				std::complex<double> x2 = 0+0j; 	
+				std::complex<double> x3 = 0+0j; 	
+				std::complex<double> x4 = 0+0j; 
+
+				std::complex<double> c1 = 1 + 0j; 	
+				std::complex<double> c2 = 2 + 0j; 	
+				std::complex<double> c3 = 3 + 0j; 	
+				std::complex<double> c4 = 4 + 0j; 	
+				std::complex<double> c6 = 6 + 0j; 	
+				std::complex<double> c8 = 8 + 0j; 	
+				std::complex<double> c9 = 9 + 0j; 	
+				std::complex<double> c12 = 12 + 0j; 	
+				std::complex<double> c16 = 16 + 0j; 	
+				std::complex<double> c27 = 27 + 0j; 	
+				std::complex<double> c36 = 36 + 0j; 	
+
+				std::complex<double> sinPhi_c = sinPhi + 0j; 	
+				std::complex<double> w_c = w + 0j; 	
+				std::complex<double> Gamma_c = Gamma + 0j; 	
+				
+				x1 = -c1/c2*sinPhi_c*w_c - c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
+				c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
+				c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
+				c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) +
+				c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
+
+				x2 = -c1/c2*sinPhi_c*w_c + c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
+				c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
+				c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
+				c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) +
+				c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
+
+
+				x3 = -c1/c2*sinPhi_c*w_c - c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
+				c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
+				c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
+				c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) -
+				c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) + c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
+			
+				x4 = -c1/c2*sinPhi_c*w_c + c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
+				c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
+				c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
+				c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) -
+				c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) + c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
+				c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
+				- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
+				c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
+				c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
+				(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
+				c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
 
-					doublereal a = dBladePos[i](2) ; 
-					doublereal b = dBladePos[i](3) ;
-					
-					doublereal c = ((2*(m*b+a))/(m*m+1)) - a ; // Mirror image point first coordinate  
-					doublereal d = ((2*m*(m*b+a))/(m*m+1)) - b ; // Mirror image point second coordinate 
 
 
-					doublereal MirrorAzimuth = atan2(d,c); // Mirror image point's Azimuth angle in the global frame 
-					if (MirrorAzimuth < 0)
+				// Choose the real positive root 
+				if (x1.real() > 0 && fabs(x1.imag()) < 0.000001)
 					{
-						MirrorAzimuth = MirrorAzimuth + 2*M_PI ; 
-					}
-					MirrorPointIndex = MirrorAzimuth / (dOmega*dDeltaT);
-					
-
-					w = 2*dIndVelMegAll[MirrorPointIndex]/sin(dAngleBtBladeAndNetforce[i] - M_PI/2);
+						dBladeUindMag[i] = x1.real() ;
+					}else if(x2.real() > 0 && fabs(x2.imag()) < 0.000001)
+					{
+						dBladeUindMag[i] = x2.real() ;
+					}else if(x3.real() > 0 && fabs(x3.imag()) < 0.000001)
+					{
+						dBladeUindMag[i] = x3.real();
+					}else if(x4.real() > 0 && fabs(x4.imag()) < 0.000001)
+					{
+						dBladeUindMag[i] = x4.real();
+					}		
 
-					//////////////////////////////////////////
-					//Find induced velocity using roots   
-					#if 1
-					// Direct root calculation method to find the induced velocity in lower-half of the rotor
-					float sinPhi = sin(dAngleBtBladeAndNetforce[i] - M_PI/2);
-					float Gamma = pow(((dKappaDMST*dBladeFroce[i].Norm()*NBlades)/(4*M_PI*dRho*dRadius)),2);
-					/*x1, x2, x3 and x4 are the roots of the 4th order polynomial*/
-					std::complex<double> x1 = 0+0j; 	
-					std::complex<double> x2 = 0+0j; 	
-					std::complex<double> x3 = 0+0j; 	
-					std::complex<double> x4 = 0+0j; 
-
-					std::complex<double> c1 = 1 + 0j; 	
-					std::complex<double> c2 = 2 + 0j; 	
-					std::complex<double> c3 = 3 + 0j; 	
-					std::complex<double> c4 = 4 + 0j; 	
-					std::complex<double> c6 = 6 + 0j; 	
-					std::complex<double> c8 = 8 + 0j; 	
-					std::complex<double> c9 = 9 + 0j; 	
-					std::complex<double> c12 = 12 + 0j; 	
-					std::complex<double> c16 = 16 + 0j; 	
-					std::complex<double> c27 = 27 + 0j; 	
-					std::complex<double> c36 = 36 + 0j; 	
-
-					std::complex<double> sinPhi_c = sinPhi + 0j; 	
-					std::complex<double> w_c = w + 0j; 	
-					std::complex<double> Gamma_c = Gamma + 0j; 	
-					
-					x1 = -c1/c2*sinPhi_c*w_c - c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
-					c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
-					c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
-					c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) +
-					c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
-
-					x2 = -c1/c2*sinPhi_c*w_c + c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
-					c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
-					c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
-					c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) +
-					c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
-
-
-					x3 = -c1/c2*sinPhi_c*w_c - c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
-					c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
-					c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
-					c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) -
-					c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) + c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
+				doublereal MagHold = dBladeUindMag[i]; 
+				// Hold the value from Analytical method to compare it with bisection method   	
+				#endif
 				
-					x4 = -c1/c2*sinPhi_c*w_c + c1/c2*sqrt(c2*pow(sinPhi_c,c2)*pow(w_c,c2) - c4/c3*pow(w_c,c2) - c1/c9*(pow(w_c,c4) -
-					c12*Gamma_c)/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c +
-					c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) -
-					c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) - c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)) -
-					c6*(pow(sinPhi_c,c3)*pow(w_c,c3) - sinPhi_c*pow(w_c,c3))/sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) - pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))) + c1/c6*sqrt((pow(w_c,c4) + c3*pow((c1/c27*pow(w_c,c6) -
-					c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3))*(c3*pow(sinPhi_c,c2) - c2)*pow(w_c,c2) - c12*Gamma_c + c9*pow((c1/c27*pow(w_c,c6)
-					- c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) - c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) -
-					c1)*pow(w_c,c8) - (c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c2/c3)))/pow((c1/c27*pow(w_c,c6) - c2/c3*(c3*pow(sinPhi_c,c2)*pow(w_c,c2) -
-					c2*pow(w_c,c2))*Gamma_c + c2/c3*sqrt(c1/c3)*sqrt(-((pow(sinPhi_c,c2) - c1)*pow(w_c,c8) -
-					(c27*Gamma_c*pow(sinPhi_c,c4) - c36*Gamma_c*pow(sinPhi_c,c2) + c8*Gamma_c)*pow(w_c,c4) -
-					c16*pow(Gamma_c,c2))*Gamma_c)),(c1/c3)));
-
-
+				#if 1
+				// Find dBladeUindMag[i] using Bisection method
+				doublereal dUindLowLimit = 0.;
+				doublereal dUindUpLimit = 100. ;
+				doublereal functionValue  ;
+				doublereal tol = 1e-12; // tolerance in calculating the root of the equation
+				doublereal DomainLenght = dUindUpLimit - dUindLowLimit ;
 
-					// Choose the real positive root 
-					if (x1.real() > 0 && fabs(x1.imag()) < 0.000001)
-						{
-							dBladeUindMag[i] = x1.real() ;
-						}else if(x2.real() > 0 && fabs(x2.imag()) < 0.000001)
-						{
-							dBladeUindMag[i] = x2.real() ;
-						}else if(x3.real() > 0 && fabs(x3.imag()) < 0.000001)
-						{
-							dBladeUindMag[i] = x3.real();
-						}else if(x4.real() > 0 && fabs(x4.imag()) < 0.000001)
-						{
-							dBladeUindMag[i] = x4.real();
-						}		
-
-					doublereal MagHold = dBladeUindMag[i]; 
-					// Hold the value from Analytical method to compare it with bisection method   	
-					#endif
-					
-					#if 1
-					// Find dBladeUindMag[i] using Bisection method
-					doublereal dUindLowLimit = 0.;
-					doublereal dUindUpLimit = 100. ;
-					doublereal functionValue  ;
-					doublereal tol = 1e-12; // tolerance in calculating the root of the equation
-					doublereal DomainLenght = dUindUpLimit - dUindLowLimit ;
+				while (DomainLenght > tol) // iterative method to find the induced velocity in lower half of the rotor
+				{
+					dBladeUindMag[i] = (dUindLowLimit + dUindUpLimit)/2.0 ;
+					functionValue = ( pow(dBladeUindMag[i],2) * ( pow(w,2) + 2*dBladeUindMag[i]*w*sin(dAngleBtBladeAndNetforce[i] - M_PI/2) + pow(dBladeUindMag[i],2) )
+					 - pow(((dKappa*dBladeForce[i].Norm()*NBlades)/(4*M_PI*dRho*dRadius)),2) ) ;
 
-					while (DomainLenght > tol) // iterative method to find the induced velocity in lower half of the rotor
+					if( functionValue >= 0.)
 					{
-						dBladeUindMag[i] = (dUindLowLimit + dUindUpLimit)/2.0 ;
-						functionValue = ( pow(dBladeUindMag[i],2) * ( pow(w,2) + 2*dBladeUindMag[i]*w*sin(dAngleBtBladeAndNetforce[i] - M_PI/2) + pow(dBladeUindMag[i],2) )
-						 - pow(((dKappaDMST*dBladeFroce[i].Norm()*NBlades)/(4*M_PI*dRho*dRadius)),2) ) ;
-
-						if( functionValue >= 0.)
-						{
-							dUindUpLimit = dBladeUindMag[i] ;
-						}else
-						{
-							dUindLowLimit = dBladeUindMag[i] ;
-						}
-						DomainLenght = fabs(dUindUpLimit - dUindLowLimit);
-					};
-					#endif
-
-					//comparision of analytical and bisection method	
-					// std::cout << MagHold << "\t" << dBladeUindMag[i] << std::endl;
-
-					// Calculating the Induced velocity component Lower Half
-					dBladeUind[i] = ::Zero3;
-					if (dT > std::numeric_limits<doublereal>::epsilon())
+						dUindUpLimit = dBladeUindMag[i] ;
+					}else
 					{
-						// Option 1: Blade Azimuth location
-						dBladeUind[i](2) = dBladeUindMag[i]*dBladePos[i](2)/dBladePos[i].Norm() - w*NetFroce(2)/NetFroce.Norm();
-						dBladeUind[i](3) = dBladeUindMag[i]*dBladePos[i](3)/dBladePos[i].Norm() - w*NetFroce(3)/NetFroce.Norm();
-
-						// Option 2: Local blade net force vector direction
-						// dBladeUind[i](2) = dBladeUindMag[i]*dBladeFroce[i](2)/dBladeFroce[i].Norm() - w*NetFroce(2)/NetFroce.Norm();
-						// dBladeUind[i](3) = dBladeUindMag[i]*dBladeFroce[i](3)/dBladeFroce[i].Norm() - w*NetFroce(3)/NetFroce.Norm();
-						
-						// Option 3: According to the Article BRNDICT ET AL   
-						// dBladeUind[i](2) = dBladeUindMag[i] + w*dBladePos[i](3)/dBladePos[i].Norm();		
-						// dBladeUind[i](3) = w*dBladePos[i](2)/dBladePos[i].Norm();		
+						dUindLowLimit = dBladeUindMag[i] ;
 					}
+					DomainLenght = fabs(dUindUpLimit - dUindLowLimit);
+				};
+				#endif
 
-					dBladeUind[i](1) = (1 - dWeight)*dBladeUind[i](1) + dWeight*dBladeUindPrev[i](1);
-					dBladeUind[i](2) = (1 - dWeight)*dBladeUind[i](2) + dWeight*dBladeUindPrev[i](2);
-					dBladeUind[i](3) = (1 - dWeight)*dBladeUind[i](3) + dWeight*dBladeUindPrev[i](3);
-					///////////////////////////////////////////
-				}   
-			}
+				//comparision of analytical and bisection method	
+				// std::cout << MagHold << "\t" << dBladeUindMag[i] << std::endl;
+
+				// Calculating the Induced velocity component Lower Half
+				dBladeUind[i] = ::Zero3;
+				if (dT > std::numeric_limits<doublereal>::epsilon())
+				{
+					// Option 1: Blade Azimuth location
+					// dBladeUind[i](2) = dBladeUindMag[i]*dBladePos[i](2)/dBladePos[i].Norm() - w*NetFroce(2)/NetFroce.Norm();
+					// dBladeUind[i](3) = dBladeUindMag[i]*dBladePos[i](3)/dBladePos[i].Norm() - w*NetFroce(3)/NetFroce.Norm();
+
+					// Option 2: Local blade net force vector direction
+					// dBladeUind[i](2) = dBladeUindMag[i]*dBladeForce[i](2)/dBladeForce[i].Norm() - w*NetFroce(2)/NetFroce.Norm();
+					// dBladeUind[i](3) = dBladeUindMag[i]*dBladeForce[i](3)/dBladeForce[i].Norm() - w*NetFroce(3)/NetFroce.Norm();
+					
+					// Option 3: Rotor, Net thrust vector direction
+					dBladeUind[i](2) = fabs(dBladeUindMag[i]-w)*F(2)/dT;
+					dBladeUind[i](3) = fabs(dBladeUindMag[i]-w)*F(3)/dT;
+
+					// Option 3: According to the Article BRNDICT ET AL   
+					// dBladeUind[i](2) = dBladeUindMag[i] + w*dBladePos[i](3)/dBladePos[i].Norm();		
+					// dBladeUind[i](3) = w*dBladePos[i](2)/dBladePos[i].Norm();		
+				}
+
+				dBladeUind[i](1) = (1 - dWeight)*dBladeUind[i](1) + dWeight*dBladeUindPrev[i](1);
+				dBladeUind[i](2) = (1 - dWeight)*dBladeUind[i](2) + dWeight*dBladeUindPrev[i](2);
+				dBladeUind[i](3) = (1 - dWeight)*dBladeUind[i](3) + dWeight*dBladeUindPrev[i](3);
+				///////////////////////////////////////////
+			}   
 		}
 	}
-
+	
 	ResetForce();
 	WorkVec.Resize(0);
 	return WorkVec;
@@ -2349,19 +2345,10 @@
 		}
 	}
 
-	if (uLabel == uBlade[0]) // First blade
-	{
-		doublereal Blade1Azimuth = atan2(X(2),X(1));
-		if (Blade1Azimuth < 0)
-		{
-			Blade1Azimuth = Blade1Azimuth + 2*M_PI ;
-		}
-	}
-
-	std::cout << uLabel << "\t" << "2D" << "\t" << dUind << "\t" << "DMST" << "\t" << dUindSet << std::endl;
+	// std::cout << uLabel << "\t" << "2D" << "\t" << dUind << "\t" << "DMST" << "\t" << dUindSet << "\t" << dUindSet.Norm() << std::endl;
 	
-	// return RRotor*dUindSet;
-	return RRotor*dUind;
+	return RRotor*dUindSet;
+	// return RRotor*dUind;
 }
 
 /* CyclocopterDMST - end */
